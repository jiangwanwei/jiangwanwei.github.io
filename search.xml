<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[搭建自己的服务器（阿里云Linux）]]></title>
    <url>%2F2019%2F09%2F05%2F%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[购买登录阿里云-云服务器ECS选择配置。ssh登录进入控制台-云服务器ECS，选择实例，初次进入需要设置登录密码（更多-密码/秘钥-重置实例密码），然后通过命令行 ssh -lroot yourIP(-l 指定登录用户名) 或者 ssh root@yourIP进行连接，然后输入密码（后期可以设置 authorized_keys 来免密登录）重置系统有时间你对当前服务器的管理不如意（搞不清楚）时，那么需要重头来玩服务器，进入控制台选中实例-更多-磁盘与镜像-重新初始化磁盘 来完成重置系统，重置系统后登录时需要对上一次进入系统记录的用户信息进行清理，否则会提示12345678910111213@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!Someone could be eavesdropping on you right now (man-in-the-middle attack)!It is also possible that a host key has just been changed.The fingerprint for the ECDSA key sent by the remote host isSHA256:8hgJ8jpcBr1tm6HS72FpXwMrjba8MQqlqYJQLPB/Qf4.Please contact your system administrator.Add correct host key in /Users/jiangwanwei/.ssh/known_hosts to get rid of this message.Offending ECDSA key in /Users/jiangwanwei/.ssh/known_hosts:26ECDSA host key for xx.xx.xx.xx has changed and you have requested strict checking.Host key verification failed.原因是因为才重装系统后，再次进行远程连接上，在输入yes后，本机会将远程机器的信息，写到/Users/jiangwanwei/.ssh/known_hosts文件中，所以如果远程重装系统了，本机一定要先清理掉。（删除对应你服务器ip的那条记录）。开启端口新增端口需要到实例上面开启后才能生效，实例 - 更多 - 网络和安全组 - 安全组配置 - 配置规则 - 添加规则组 ，写入端口范围 例如 8080/8080 授权对象 设置为 0.0.0.0/0 。设置完成后重启服务器。需要注意开启端口、或者是修改密码后都需要重启服务器（选中服务-重启）yum介绍Yum(全称为 Yellow dogUpdater, Modified)是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。配置路径为 /etc/yum.conf, 常用配置：1234cachedir=/var/cache/yum #yum下载的RPM包的缓存目录keepcache=0 #缓存是否保存，1保存，0不保存。debuglevel=2 #调试级别(0-10)，默认为2logfile=/var/log/yum.log #yum的日志文件所在的位置常用操作：安装123$ yum install 全部安装$ yum install package1 安装指定的安装包package1$ yum groupinsall group1 安装程序组group1更新和升级12345$ yum update 全部更新$ yum update package1 更新指定程序包package1$ yum check-update 检查可更新的程序$ yum upgrade package1 升级指定程序包package1$ yum groupupdate group1 升级程序组group1查找和显示1234$ yum info package1 显示安装包信息package1$ yum list 显示所有已经安装和可以安装的程序包$ yum list package1 显示指定程序包安装情况package1$ yum groupinfo group1 显示程序组group1信息yum search string 根据关键字string查找安装包删除程序123$ yum remove erase package1 删除程序包package1$ yum groupremove group1 删除程序组group1$ yum deplist package1 查看程序package1依赖情况清除缓存1234$ yum clean packages 清除缓存目录下的软件包$ yum clean headers 清除缓存目录下的 headers$ yum clean oldheaders 清除缓存目录下旧的 headers$ yum clean, yum clean all (= yum clean packages; yum clean oldheaders) 清除缓存目录下的软件包及旧的header安装nginx123$ yum install epel-release # 下载 epel-release$ yum install nginx # 下载 nginx$ cd /etc/nginx # 配置epel-release：EPEL (Extra Packages for Enterprise Linux，企业版Linux的额外软件包) 是Fedora小组维护的一个软件仓库项目，为RHEL/CentOS提供他们默认不提供的软件包。这个源兼容RHEL及像CentOS和Scientific Linux这样的衍生版本。可以很容易地通过yum命令从EPEL源上获取上万个在CentOS自带源上没有的软件。EPEL提供的软件包大多基于其对应的Fedora软件包，不会与企业版Linux发行版本的软件发生冲突或替换其文件。安装nodejs123456789# 下载$ wget https://npm.taobao.org/mirrors/node/v12.9.1/node-v12.9.1-linux-x64.tar.xz# 解压$ tar -xvf node-v12.9.1-linux-x64.tar.xz# 移动到 /usr# 建立软连接$ ln -s /usr/local/share/applications/nodejs/bin/* /usr/local/bin/需要注意的一点 通过npm安装的全局包 如果有出现包命令没有加入到全局环境变量时需要手动 在执行以下软连接 ln -s /usr/local/share/applications/nodejs/bin/* /usr/local/bin/，但是每次安装全局包后都要执行，更好的办法是执行一次 echo -e &quot;export PATH=$(npm prefix -g)/bin:$PATH&quot; &gt;&gt; ~/.bashrc &amp;&amp; source ~/.bashrc 来新增npm全局命令道环境变量PATH中（秩序执行一次）。systemctlsystemctl 命令的两大作用，1、控制 systemd 系统 2、管理系统上运行的服务。常用操作(以nginx为例)：123456789101112131415161718192021222324252627282930# 1.启动nfs服务$ systemctl start nginx# 2.设置开机自启动$ systemctl enable nginx# 3.停止开机自启动$ systemctl disable nginx# 4.查看服务当前状态$ systemctl status nginx# 5.重新启动某服务$ systemctl restart nginx# 6.查看所有已启动的服务$ systemctl list -units --type=service# 开启防火墙22端口$ iptables -I INPUT -p tcp --dport 22 -j ACCEPT# 如果仍然有问题，就可能是SELinux导致的# 关闭SElinux：# 修改/etc/selinux/config文件中的SELINUX=”” 为 disabled，然后重启# 彻底关闭防火墙：$ systemctl status firewalld.service$ systemctl stop firewalld.service $ systemctl disable firewalld.service至此，服务器nginx 和nodejs都安装好了，可以愉快的玩耍了。。。]]></content>
      <categories>
        <category>Linux服务器</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>阿里云</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[taro开发注意事项]]></title>
    <url>%2F2019%2F09%2F04%2Ftaro%E5%BC%80%E5%8F%91%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[近两个项目的开发采用的是 Taro 多终端开发框架，一个为优电车管段微信小程序、另一个是奇遇的Wap版本，这里列一下我在开发中遇到的注意事项。框架简介用官方的一句简单的概括就是 “多端统一开发解决方案”（京东 凹凸实验室 出品，star 20131），重点是一套 遵循 React 语法规范 的 多端开发 解决方案。这也就能帮我们前端er们解决这个多终端的问题，帮我们节省大量开发时间，从此以后 wap、微信小程序、支付宝小程序、百度小程序、快应用、字节跳动小程序、qq轻应用、ReactNative 一套代码轻松搞定，当然由于各个终端格子的表现形式不一，我们不得不针对性的做一些代码兼容（官方也提供兼容处理形式：以文件后缀来区分针对不同的端打包运行 eg: vehicle.h5.js 只会针对h5运行…，以及环境变量的提供 process.env.TARO_ENV = weapp / swan / alipay / h5 / rn / tt，具体开发场景自己针对性的选择），但很明显也比同样的功能正对不同的平台多次开发便利很多。语法风格Taro 的语法规则基于 React 规范，它采用与 React 一致的组件化思想，组件生命周期与 React 保持一致，同时在书写体验上也尽量与 React 类似，支持使用 JSX 语法，让代码具有更丰富的表现力。但是有一点就是react更新后的一段时间 Taro才会更新相同的语法功能，例如hooks在我们现在使用的版本未支持，但是其实react很早就更新了这块内容，而taro在1.30 bate版本才支持。现在多端开发有基于react语法的taro、也有基于vue的uniapp，滴滴的chameleon等，说明这一块值得我们前端掌握。因为小微信小程序、支付宝小程序等api以及写法都大同小异的比较难用。不足2018年4月份第一个正式版推出第一个版本，到现在的时间也不过才一年多：1、存在bug 比如选择上传方法 Taro.chooseImage 在小程序表现正常但是在H5中选择返回的File对象无效的问题，在1.3的版本里面已经修复(多上issues找找，或许你遇到的问题能找到决绝方案)。2、生态圈不成熟 虽然能像写 react 一样开发，但是要在taro中使用必须要针对taro开发，也就是说基于react的小工具、插件等不能运行在taro，我们不得不自己去做一些轮子。（目前Taro团队也在征集优秀的库 官方物料市场, 看样子征集不理想还比较少，质量也貌似不太好）3、React自身部分语法不能使用 因为是多终端，所以像wap能用的BOM方法、DOM方法以及react能用的方法等在其他端就不能生效等。(cache、localstorage、React.createClass等)4、配置存在差异 react中我们大多完全基于webpack打包，而在taro中webpack配置只是配置中的一部分，所以你熟悉之前写webpack配置在taro中会存在写法上的差异，但是大同小异。5、代码写法差异 比如react引用中请求可以用其他任意工具比如axios、fetch等，但是在taro中只能用 Taro.request ，其他还有分享等。…尽管才出来一年多，但是还是有很多不少的公司已投入生产环境，其中不乏大公司的部分业务在使用（京东、拼多多、猫眼等）安装12345# 使用 yarn 安装 CLI$ npm install -g @tarojs/cli# 创建项目$ taro init myAppcli 很重要，必须安装并且和开发依赖的taro包保持一致。比如我们开发中依赖的 taro版本为1.2.23，那么cli的版本对应的要一致，因为我们在开发中，以及生产打包都会用到cli，如果我们依赖的版本高，而我们本地cli版本低，那么就会存在部分语法在cli中不识别从而导致打包或运行失败。安装成功后可以看到目录结构跟我们 用 cerate-react-app 创建的目录差不多, 数据方面我们选择的模板是redux，异步数据saga的安装方式没有变化。配置项目配置：各个平台有自己的配置文件。(微信小程序，project.config.json、百度智能小程序，project.swan.json、快应用，manifest.json) 其他平台暂无；打包配置：/config/dev.js | /config/prod.js 中对应的webpack配置方式（小程序和h5有单独自己的配置.h5 .weapp），例如：123456789101112131415161718192021222324252627282930313233343536373839module.exports = &#123; env: &#123; NODE_ENV: '"development"' &#125;, defineConstants: &#123; &#125;, weapp: &#123;&#125;, h5: &#123; devServer: &#123; port: 10087, proxy: &#123; '/api/': &#123; target: 'https://motoapi.sodacar.com', pathRewrite: &#123; '^/api/': '/' &#125;, changeOrigin: true &#125;, '/auth/': &#123; target: 'https://motoauthapi.sodacar.com', pathRewrite: &#123; '^/auth/': '/' &#125;, changeOrigin: true &#125;, &#125; &#125;, // 合并reducers 和sagas webpackChain (chain, webpack) &#123; chain.merge(&#123; plugin: &#123; install: &#123; plugin: new reduxSagaHelperPlugin(), &#125; &#125; &#125;) &#125; &#125;&#125;我们更多的关注的是 webpackChain、devServer、router、cssModule、alias、plugins 的配置。详细参考 编译配置详情需要提一下的就是全局plugin，目前有四个固定的配置babel、uglify、csso、sass，配置api和官方一模一样。例如我们需要配置sass相关:1234567891011121314...plugins: &#123; sass: &#123; resource: path.resolve(__dirname, '..', 'src/styles/variable.scss'), // OR // resource: ['path/to/global.variable.scss', 'path/to/global.mixin.scss'] projectDirectory: path.resolve(__dirname, '..'), data: '$nav-height: 48px;', &#125;&#125;// resource: 如果要引入多个文件，支持数组形式传入// projectDirectory: 项目根目录的绝对地址(若为小程序云开发模板，则应该是client目录)// data: 全局 scss 变量，若 data 与 resource 中设置了同样的变量，则 data 的优先级高于 resource...路由路由方面来说跟 react 比起来，那就差的太多了，最多只能用过高阶组件来做到一些公用的逻辑操作（例如身份验证等），应该是考虑到小程序是没有组件继承的说法（当然H5相对支持要好些，比如能支持组件反向继承时对render进行劫持来做一些判断性的组件显示等，看到taro官方说后续会进行实现）。路由配置都是在 src/app.js 中, 如：123456789class App extends Component &#123; config = &#123; pages: [ 'pages/index/index', 'pages/login/index', 'pages/notFound/index', ], ...跳转api为 Taro.navigateTo, 例如：1234567891011// 传入参数 id=2&amp;type=testTaro.navigateTo(&#123; url: '/pages/page/path/name?id=2&amp;type=test'&#125;)// 获取方式class C extends Taro.Component &#123; componentWillMount () &#123; console.log(this.$router.params) // 输出 &#123; id: 2, type: 'test' &#125; &#125;&#125;需要注意的是：this.$router.path 所返回的内容H5和小程序存在差异，小程序返回页面路径 /pages/login/index，而H5返回的是 config/index.js 中的 h5.router.customRoutes 配置，也就是浏览器路径 /login(hash、history模式相同)。为了保持多终端通用，很显然 wap能用的 hash 就不能使用了。在h5中，原生的跳转跟 src/app.js 中配置的路径不一样，例如 &#39;pages/index/index&#39; 在浏览器对应的地址就是 http://localhost:3000/#/pages/index/index， 很显然难以接受，如果需要使用我们习惯的 history 模式，我们需要在配置中( /config/index.js )做如下类似的修改:1234567891011h5: &#123; publicPath: '/', ... // 路由配置 router: &#123; mode: 'browser', basename: '/', // 基准路径的配置 customRoutes: &#123; // 自定义路由配置 '/pages/index/index': '/index', '/pages/my/index': '/my', '/pages/my/info/index': '/my/info',调用 Taro.navigateTo({ url: ‘/pages/index/index’ }) 后，浏览器地址栏将被变为 http:///index。跳转 ?page=1 or #hash 页面都会刷新，所有生命周期都会重新执行。注意：Taro.navigateTo 的 url 参数必须 填写 customRoutes 配置中的key，不能 使用 Taro.navigateTo({ url: ‘/my’ })。路由H5 404处理目前没有看到处理方式，包括官方的例子的（h5）404都没有做处理，直接报错白屏。目前项目中使用的处理方式比较粗暴：12345678// 自定义H5 404跳转if (isH5) &#123; window.onerror = e =&gt; &#123; if (e.match('Can not find proper registered route for')) &#123; location = '/' &#125; &#125;&#125;样式方面无差别，app.js 中 import &#39;global.scss&#39; 为全局通用。组件中 引用 import style from &#39;index.module.scss&#39; 即可。样式的写法上，各个终端存在一定的差异。例如 background: #fff url(xxx.png) 30px/100px no-repeat; 简写在RN中不能生效、以及部分属性不支持等。推荐使用flex布局，由于RN 只支持flex布局（更重要的是flex布局使用更方便，现在的设备支持情况也良好）。详情可参考 样式的条件编译 | 特殊问题的处理 | 组件的外部样式和全局样式。UI组件差异跟小程序类似，只能使用自己的组件 例如 View\Text等，但是在H5中能使用 web自己的组件(div、header、footer等)。如果考虑多终端，那么就不要使用平台自身的东西。UI库就没有react那么丰富了，目前只有官方提供的库 TaroUI (目前以后 2271 star)。生命周期相差无几，多了 componentDidShow，相当于 react 中的 componentWillMount ，小程序中的 onShow。另外多了一个 config 配置：123456789export default class Index extends Component &#123; config = &#123; navigationBarBackgroundColor: '#ffffff', navigationBarTextStyle: 'black', navigationBarTitleText: '首页', backgroundColor: '#eeeeee', backgroundTextStyle: 'light' &#125; ...相对的是 小程序的对应的配置。navigationBarTitleText 与 document.title 相等。还有小程序专属的函数：下拉刷新事件: onPullDownRefresh() 上拉触底事件: onReachBottom() 滑动页面 onPageScroll() 分享配置onShareAppMessage()等等 详细配置。还有就是 componentWillMount 表现差异问题，由于小程序里在 onLoad 里才能拿到路由参数信息，而页面 onLoad 前组件已经固定了。因此页面的 componentWillMount 会有和预期表现不一致的问题。处理方法可以用state存起来。建议放到都放到 DidMount 中执行，因为本身react的 WillMount 是存在重复执行的bug最后一个taro 提供了一个预加载的钩子 componentWillPreload, 因为在小程序中，从调用 Taro.navigateTo、Taro.redirectTo 或 Taro.switchTab 后，到页面触发 componentWillMount 会有一定延时。因此一些网络请求可以提前到发起跳转前一刻去请求。 而 componentWillPreload 就是为了处理这个问题，它接收页面跳转的参数作为参数。可以把需要预加载的内容通过 return 返回，然后在页面触发 componentWillMount 后即可通过 this.$preloadData 获取到预加载的内容。eg:1234567891011121314151617181920// 官方例子class Index extends Component &#123; componentWillMount () &#123; console.log('isFetching: ', this.isFetching) this.$preloadData .then(res =&gt; &#123; console.log('res: ', res) this.isFetching = false &#125;) &#125; componentWillPreload (params) &#123; return this.fetchData(params.url) &#125; fetchData () &#123; this.isFetching = true ... &#125;&#125;渲染组件props的值如果是组件 那么参数名称必须以 rednerXXX开头的驼峰形式。但是 children 可以传任意类型。eg:123456789101112131415161718&lt;MyComponent renderHeader=&#123;&lt;View className=&#123;`xxx`&#125;&gt;&lt;/View&gt;&#125; /&gt; // correct// 这样同样会有错误（h5没问题、小程序中存在错误）render() &#123; const renderSuffix = &lt;Text&gt;1&lt;/Text&gt; return &lt;MyComponent renderSuffix=&#123;renderSuffix&#125;&gt;&#125; // error// 这样则正确render() &#123; return &lt;MyComponent renderSuffix=&#123;&lt;Text&gt;1&lt;/Text&gt;&#125;&gt;&#125; // correct// renderSuffix 内容只能是 jsx, 不能为其他的（H5中可以是任意类型、但是小程序中必须为jsx）暂不支持在 render() 之外的方法定义 JSX (v1.3.0-beta.0 起支持)不能在 JSX 参数中使用对象展开符 (v1.3.0-beta.0 起，自定义组件可以使用对象展开符，内置组件仍然需要分别单独传入参数) eg:12345let params = &#123;a: 1, b: 2&#125;&lt;MyComponent ...params /&gt; // error&lt;MyComponent a=&#123;params.a&#125; ... /&gt;在 Taro 中，父组件要往子组件传递函数，属性名必须以 on 开头，这是因为微信小程序端组件化是不能直接传递函数类型给子组件的，在 Taro 中是借助组件的事件机制来实现这一特性，而小程序中传入事件的时候属性名写法为 bindmyevent 或者 bind:myevent。给组件设置 defaultProps：我们知道在小程序中组件属性只有定义在 properties 中，才能被识别，eg:1234567891011121314Component(&#123; properties: &#123; props1: &#123; // 属性名 type: String, // 类型（必填），目前接受的类型包括：String, Number, Boolean, Object, Array, null（表示任意类型） value: '', // 属性初始值（可选），如果未指定则会根据类型选择一个 observer: (newVal, oldVal, changedPath) =&gt; &#123; // 属性被改变时执行的函数（可选），也可以写成在 methods 段中定义的方法名字符串, 如：'_propertyChange' // 通常 newVal 就是新设置的数据， oldVal 是旧数据 &#125; &#125;, props2: String, // 简化的定义方式 &#125; ...&#125;)而在taro中规定则是每个组件属性必须定义在 defaultProps 中，eg:123456class Component extends Taro.Component &#123; static defaultProps = &#123; props1: '', ... &#125;&#125;通过设置 defaultProps 在运行时用来处理编译时处理不到的异常情况，而所有的属性都会被追加到 properties 中初始化组件，设置正确的 defaultProps 能够避免一些异常的情况的出现。不要用 id、class、style 作为自定义组件的 props 与内部 state 的名称，因为这些属性名在微信小程序中会丢失。不要在 state 与 props 中用相同名称的字段，原因是这些被字段在转成小程序后都会放到 this.data 上（eg：会触发错误 ESLint(taro/duplicate-name-of-state-and-props) 错误：this.state.value 与 this.props.value 重复可能会导致渲染结不如意料之中的结果）。Taro 里尽量使用单引号，尤其是 JSX，使用双引号 可能会导致编译错误。在JSX中，不支持柯里化（自 v1.3.0-beta.1 开始支持）。export { default as iconEye } from &#39;./eye.png&#39; 暂时不支持这样统一暴露。小程序jsx中不要写匿名函数，会遇到的情况就是H5解析没问题，但是在小程序解析时会报错。小程序高阶组件中的 super.render() 在小程序中无法使用，因为小程序编译后是没有render的，jsx 部分会被编译成 wxml，return 之前的数据处理会被编译到 _createData() 方法里。小程序自定义组件不能和 内置组件名称相同 （Button Input 等），会触发 Error: 内置组件名: &#39;Input&#39; 只能从 @tarojs/components 引入。 错误提示。小程序循环中的 ref 只能使用函数。(ref 仅支持传入字符串、匿名箭头函数和 class 中已声明的函数) 小程序组件事件传参只能在使用匿名箭头函数，或使用类作用域下的确切引用(this.handleXX || this.props.handleXX)，或使用 bind。小程序render 函数定义一个不从 this.state 解构或赋值而来的变量，此变量又与 this.state 下的变量重名可能会导致无法渲染。小程序 eg:12345678910111213141516171819202122232425...render() &#123; const &#123; len, error, focus, complite, &#125; = this.props const &#123; value &#125; = this.state const gridStyle = `$&#123;styles.grid&#125; $&#123;error ? (value.length === len &amp;&amp; styles.err) : ''&#125;` return ( &lt;View className=&#123;styles.box&#125;&gt; &lt;MYInput focus=&#123;value.length === len ? false : focus&#125; // 长度达到6位自动隐藏键盘 className=&#123;styles.ipt&#125; type='number' onInput=&#123;e =&gt; &#123; const value = e.detail.value // 这里定义的value会触发此错误，解决方案此处的value更换为不予state.value字段重复即可 this.setState(&#123; value &#125;, e =&gt; &#123; if (value.length === len) &#123; try &#123; this.inputRef.inputRef.blur() complite(this) &#125; catch (e) &#123; Toast(&#123; title: e.message, icon: 'error' &#125;) &#125; &#125; &#125;) &#125;&#125;...在 scss 中第一样和最后一行 注释 不能使用 // 注释内容, 解决方案 要么使用 /* 注释内容 */ 或者 删掉注释。小程序this.props.children 为只读, 如需在自定义方法中调用 需要用到ES6对象解析 const {children} = this.props，否则会触发 (taro/render-props) 错误：无法操作 this.props.children 错误。小程序自定义组件 render 不能返回 null,会触发错误 组件Marker路径错误，请检查！（可能原因是导出的组件名不正确）。小程序在样式文件里不能使用本地图作为背景图片，即 background: url(../assets....)。需要使用网络图片或者使用 &lt;Image /&gt; 标签。 小程序资源引入在react 中我们能 在jsx中动态引入图片,eg:123456...render() &#123; return &lt;Image src=&#123;require(`@/assets/images/$&#123;this.state.index&#125;.png`)&#125; /&gt;&#125;但是在taro中，目前不支持，但是他提供了一个需要手动配置的配置项 copy 来达到此目的。手动指定需要copy的目录，就ok了， eg：12345678910copy: &#123; patterns: [ &#123; from: 'src/asset/tt/', to: 'dist/asset/tt/', ignore: '*.js' &#125;, // 指定需要 copy 的目录 &#123; from: 'src/asset/tt/sd.jpg', to: 'dist/asset/tt/sd.jpg' &#125; // 指定需要 copy 的文件 ]&#125;,// used&lt;Image src=&#123;`/assets/images/$&#123;this.state.index&#125;.png`&#125; /&gt;原因是 地址替换这一步是放到编译时做的，需在编译时找到引入的图片然后 copy 到 dist 目录。跨平台开发如上简介所说：官方也提供兼容处理形式：以文件后缀来区分针对不同的端打包运行 eg: vehicle.h5.js 只会针对h5运行…，以及环境变量的提供 process.env.TARO_ENV = weapp / swan / alipay / h5 / rn / tt数据管理taro推荐使用redux来管理数据，刚好和我们相同。但是如果小项目小功能的程序那么久不适合用数据管理了(太重)。自己维护一个global.js就可以，eg:1234567891011121314151617const globalData = &#123;&#125;export function set (key, val) &#123; globalData[key] = val&#125;export function get (key) &#123; return globalData[key]&#125;// useimport &#123; set as setGlobalData, get as getGlobalData &#125; from './path/name/global_data'setGlobalData('test', 1)getGlobalData('test')性能性能方面可优化的其实跟react相差无几:可以通过 shouldComponentUpdate 来避免重复渲染以及 React.PureComponent 在taro中同样有 Taro.PureComponent，在react中新增的useMemo，taro中同样有 Taro.memo。…支付宝、微信、字节跳动小程序差异。其他注意事项已经在官网有详细的说明,开发前注意 | 特殊问题的处理 。]]></content>
      <categories>
        <category>前端</category>
        <category>多终端开发</category>
      </categories>
      <tags>
        <tag>Taro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[weex采坑记录]]></title>
    <url>%2F2018%2F09%2F13%2Fweex%E9%87%87%E5%9D%91%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[创建项目1$ weex create appname添加platform1$ weex platform add android/ios给APP签名123456789# 生成签名文件# android.keystore 文件名$ keytool -genkey -alias android.keystore -keyalg RSA -validity 20000 -keystore android.keystore# 给 apk文件 签名# android.keystore 签名文件# app-release-signed.apk 签名后的文件名# app-release-unsigned.apk 要签名的apk文件$ jarsigner -verbose -keystore android.keystore -signedjar app-release-signed.apk app-release-unsigned.apk android.keystoreError: Command failed: ./gradlew assembleRelease/platforms/android/app/build.gradle 文件里新增1234aaptOptions &#123; cruncherEnabled = false useNewCruncher = false&#125;和 defaultConfig {} 同级Cannot set the value of read-only property ‘outputFile’ for ApkVariantOutpu修改打包部分代码为：123456789applicationVariants.all &#123; variant -&gt; variant.outputs.all &#123; output -&gt; // each 改为 all def fileName = &quot;$&#123;variant.versionName&#125;_release.apk&quot; def outFile = output.outputFile if (outFile != null &amp;&amp; outFile.name.endsWith(&apos;.apk&apos;)) &#123; outputFileName = fileName // output.outputFile 改为 outputFileName &#125; &#125;&#125;Annotation processors must be explicitly declared now.在app的build中123456789android &#123; ... defaultConfig &#123; ... //添加如下配置就OK了 javaCompileOptions &#123; annotationProcessorOptions &#123; includeCompileClasspath = true &#125; &#125; &#125; ...&#125;【Android】报错INSTALL_FAILED_TEST_ONLY在真机安装APK的过程中报错：INSTALL_FAILED_TEST_ONLY在查阅网上资料后，采用以下方案成功解决：在项目的gradle.properties文件中添加android.injected.testOnly=false如果采用上述方法不能解决，请查看以下链接中的方法：https://blog.csdn.net/pengchanghua/article/details/79474759参考网址：https://blog.csdn.net/pengchanghua/article/details/79474759https://blog.csdn.net/myislijingjing/article/details/80911565图标文件夹修改替换掉文件123456789101112131415161718192021222324252627282930313233或者 修改 ```/platforms/android/app/src/main/AndroidManifest.xml``` 中得 ```android:icon``` ### APP名称修改修改 ```/platforms/android/app/src/main/res/values/strings.xml``` 和```/platforms/android/app/src/main/res/values-zh-rCN/strings.xml``` 中得 app_name### 启动页修改1、进入项目目录：\platforms\android\app\src\main\res? 新建文件夹：drawable2、把背景图片放到?drawable 文件夹里面去，我这边的图片文件名是 bg.jpg3、打开文件夹?\platforms\android\app\src\main\res\layout 找到?activity_splash.xml 文件，用编辑器打开4、修改 FrameLayout 节点的background 属性为：@drawable/bg### app 加固https://www.cnblogs.com/syw20170419/p/8081321.html### 横屏设置在 `AndroidManifest.xml` 中 的每个 `&lt;activity&gt;` 中新增/修改 `android:screenOrientation=&quot;landscape&quot;`### 关闭调试屏蔽 java 文件 WXPageActiviy `setContentView(R.layout.activity_wxpage);` 和 `mTipView.setText(&quot;render error:&quot; + errCode);`### navigator.push跳转本地文件页面空白最简单的修复方法是在WxPageActivity.java的onCreate方法try {JSONObject initData = new JSONObject(uri.toString());String bundleUrl = initData.optString(“WeexBundle”, null);if (bundleUrl != null) {mUri = Uri.parse(bundleUrl);}...... ...... } catch (JSONException e) {e.printStackTrace();}1这里catch里面加一句 `mUri = Uri.parse(uri.toString());`……} catch (JSONException e) {e.printStackTrace();mUri = Uri.parse(uri.toString());}```参考链接-1参考链接-2Android平台接入扫码模块参考地址注意的地方： ScanModule.java不需要导入这个包import com.alibaba.weex.WXPageActivity;注意事项文字必须 用 &lt;text&gt; 标签样式必须每个标签添加类名（scss 类嵌套 在真机环境下不生效）cdn字体 一个页面只需在任意一个组件里加载一次（必须给使用的标签添加类名）&lt;text&gt;&lt;/text&gt; 文字居中 用 align-self: center; 或者 text-align: center;手机竖屏版本，宽度单位为二倍像素div 嵌套不要太深(5层左右)引入vue组件必须带后缀名称, 例 import MyHeader from &#39;./components/header.vue&#39;横屏时如果出现闪屏 ，在css设置默认宽度（默认750px）:class 仅支持array syntax ，你可以通过 :class=&quot;[isTrue ? &#39;a&#39; : &#39;&#39;, &#39;b&#39;]&quot; 来判断是否要加入 ‘a’ 这个 class.:style 仅支持object syntax，例如：style=&quot;{color: index&lt;3 ? &#39;#fff&#39; : &#39;#000&#39;, &#39;border-bottom-width&#39;: index===2 ? 10 + &#39;px&#39; : &#39;0&#39;}&quot;weex 不支持 v-html 指令。(没有dom这个说法)样式单位只支持百分百（不支持百分比、em、rem、vh等）]]></content>
      <categories>
        <category>weex</category>
      </categories>
      <tags>
        <tag>weex</tag>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git查看、删除、重命名远程分支和tag]]></title>
    <url>%2F2017%2F11%2F24%2FGit%E6%9F%A5%E7%9C%8B%E3%80%81%E5%88%A0%E9%99%A4%E3%80%81%E9%87%8D%E5%91%BD%E5%90%8D%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E5%92%8Ctag%2F</url>
    <content type="text"><![CDATA[查看远程分支1$ git branch -a删除远程分支和tag在Git v1.7.0 之后，可以使用这种语法删除远程分支：1$ git push origin --delete &lt;branchName&gt;删除tag这么用：1$ git push origin --delete tag &lt;tagname&gt;否则，可以使用这种语法，推送一个空分支到远程分支，其实就相当于删除远程分支：1$ git push origin :&lt;branchName&gt;这是删除tag的方法，推送一个空tag到远程tag：12$ git tag -d &lt;tagname&gt;$git push origin :refs/tags/&lt;tagname&gt;两种语法作用完全相同。删除不存在对应远程分支的本地分支假设这样一种情况：我创建了本地分支b1并pull到远程分支 origin/b1；其他人在本地使用fetch或pull创建了本地的b1分支；我删除了 origin/b1 远程分支；其他人再次执行fetch或者pull并不会删除这个他们本地的 b1 分支，运行 git branch -a 也不能看出这个branch被删除了，如何处理？使用下面的代码查看b1的状态：123456789101112$ git remote show origin* remote origin Fetch URL: git@github.com:xxx/xxx.git Push URL: git@github.com:xxx/xxx.git HEAD branch: master Remote branches: master tracked refs/remotes/origin/b1 stale (use &apos;git remote prune&apos; to remove) Local branch configured for &apos;git pull&apos;: master merges with remote master Local ref configured for &apos;git push&apos;: master pushes to master (up to date)这时候能够看到b1是stale的，使用 git remote prune origin 可以将其从本地版本库中去除。更简单的方法是使用这个命令，它在fetch之后删除掉没有与远程分支对应的本地分支：1$ git fetch -p重命名远程分支在git中重命名远程分支，其实就是先删除远程分支，然后重命名本地分支，再重新提交一个远程分支。例如下面的例子中，我需要把 devel 分支重命名为 develop 分支：12345678910$ git branch -av* devel 752bb84 Merge pull request #158 from Gwill/devel master 53b27b8 Merge pull request #138 from tdlrobin/master zrong 2ae98d8 modify CCFileUtils, export getFileData remotes/origin/HEAD -&gt; origin/master remotes/origin/add_build_script d4a8c4f Merge branch &apos;master&apos; into add_build_script remotes/origin/devel 752bb84 Merge pull request #158 from Gwill/devel remotes/origin/devel_qt51 62208f1 update .gitignore remotes/origin/master 53b27b8 Merge pull request #138 from tdlrobin/master remotes/origin/zrong 2ae98d8 modify CCFileUtils, export getFileData删除远程分支：123$ git push --delete origin devel To git@github.com:zrong/quick-cocos2d-x.git - [deleted] devel重命名本地分支：1$ git branch -m devel develop推送本地分支：12345678$ git push origin develop Counting objects: 92, done. Delta compression using up to 4 threads. Compressing objects: 100% (48/48), done. Writing objects: 100% (58/58), 1.38 MiB, done. Total 58 (delta 34), reused 12 (delta 5) To git@github.com:zrong/quick-cocos2d-x.git * [new branch] develop -&gt; develop然而，在 github 上操作的时候，我在删除远程分支时碰到这个错误：12345$ git push --delete origin develremote: error: refusing to delete the current branch: refs/heads/develTo git@github.com:zrong/quick-cocos2d-x.git ! [remote rejected] devel (deletion of the current branch prohibited)error: failed to push some refs to &apos;git@github.com:zrong/quick-cocos2d-x.git&apos;这是由于在 github 中，devel 是项目的默认分支。要解决此问题，这样操作：进入 github 中该项目的 Settings 页面；设置 Default Branch 为其他的分支（例如 master）；重新执行删除远程分支命令。把本地tag推送到远程1$ git push --tags获取远程tag1$ git fetch origin tag &lt;tagname&gt;]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>前端工具</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb实践-基本操作]]></title>
    <url>%2F2017%2F11%2F09%2Fmongodb%E5%AE%9E%E8%B7%B5-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[linux 命令12345$ which mongod // 查看命令是否可执行$ mkdir -p /data/db // 层级创建$ df -lh // 查看根目录剩余空间启动1234567891011121314// 启动参数 (mac 权限不足 需要加sudo)$ mongod --dbpath=/data/db --port=27017 // 指定储存目录和启动端口 ，启动端口默认为27017 $ mongod --dbpath=/data/db --port=27017 --fork --syslog// fork:打印日志 syslog 日志储存在系统目录(/var/log/messages) （程序会在后台启动）// 使用 tail -f /var/log/messages 可以监听日志// 结束后台启动的mongodb mongod --shutdown 或者 kill 进程号也可以自己指定日志文件$ mongod --dbpath=/data/db --port=27017 --fork --logpath=/var/log/mongo.log (推荐)客户端启动$ mongo 或者 mongo 127.0.0.1:27017 // 127.0.0.1:27017为你要连接的地址关闭1234$ use admin$ db.shutdownServer()$ db.shutdownServer(&#123;force : true&#125;) 强制关闭Mongod，应对副本集中主从时间差超过10s时不允许关闭主库的情况不要使用kill直接杀mongo进程的方式关闭数据节点，会造成数据损坏操作命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849$ show dbs // 显示所有数据库$ use dbname // 切换到dbname数据库 (不存在自动创建)$ show collections // 查看当前表的 数据$ db.users.insert(&#123;&apos;name&apos;: &apos;ss&apos;&#125;) // 插入 users 会自动创建$ db.createCollection(&quot;mycollection&quot;) // 单独创建$ db.getCollectionNames() // 查看表数据 已数组形式返回 -&gt; [ &quot;system.indexes&quot;, &quot;system.users&quot;, &quot;system.version&quot; ]$ db.users.find() // 查找 find(&#123;&apos;name&apos;: &apos;ss&apos;&#125;) find可以跟参数 $ db.users.find().count() // 查找总数$ db.user.find().pretty() // 格式化查找内容$ db.user.find().limit(NUMBER) // 查找条数$ db.user.find().skip(NUMBER) // 跳过条数.sort(&#123;&apos;uid&apos;:1&#125;) // 排序 1 升序 -1 降序ensureIndex()方法的基本语法如下$ db.COLLECTION_NAME.ensureIndex(&#123;KEY:1&#125;)这里键是要创建索引字段，1是按名称升序排序。若以按降序创建索引，需要使用 -1.$ db.mycol.find(&#123;&quot;likes&quot;:&#123;$lt:50&#125;&#125;) === where likes &lt; 50$ db.mycol.find(&#123;&quot;likes&quot;:&#123;$lte:50&#125;&#125;) === where likes &lt;= 50$ db.mycol.find(&#123;&quot;likes&quot;:&#123;$gt:50&#125;&#125;) === where likes &gt; 50$ db.mycol.find(&#123;&quot;likes&quot;:&#123;$gte:50&#125;&#125;) === where likes &gt;= 50$ db.mycol.find(&#123;&quot;likes&quot;:&#123;$ne:50&#125;&#125;) === where likes != 50or:$ db.mycol.find( &#123; $or: [ &#123;key1: value1&#125;, &#123;key2:value2&#125; ] &#125;)$ db.users.update(&#123;username: &apos;Sid&apos;&#125;, &#123;$set: &#123;username: 222&#125;&#125;) // 更新一条&#123;username: &apos;Sid&apos;&#125;数据$ db.users.update(&#123;username: &apos;fff&apos;&#125;, &#123;$set: &#123;username: &apos;777&apos;&#125;&#125;, &#123;multi: true&#125;) // 更新所有 &#123;username: &apos;fff&apos;&#125; 的数据 &#123;multi: true&#125; 更新所有$ db.users.save(&#123;&apos;_id&apos;: ObjectId(&quot;5960f48dc93f8047ff3dcd7a&quot;), username: &apos;siddd&apos;&#125;) // 更新 id相同的数据 ，id为必填条件 后面的数据指定多少条保存多少条$ db.users.remove(&#123;username:777&#125;) // 删除所有符合条件的数据$ db.users.remove(&#123;username: &apos;777&apos;&#125;, true) // 删除第一条符合条件的数据$ db.users.remove(&#123;&#125;) // 删除文档 如果有设置索引是不会删除$ db.users.drop() // 删除文档和索引 返回 true false// 删除当前数据库$ use mydbswitched to db mydb$ db.dropDatabase()$ &#123; &quot;dropped&quot; : &quot;mydb&quot;, &quot;ok&quot; : 1 &#125;]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb添加账号密码]]></title>
    <url>%2F2017%2F11%2F09%2Fmongodb%E6%B7%BB%E5%8A%A0%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[1.输入命令：$ show dbs，你会发现它内置有两个数据库，一个名为admin，一个名为local；本文只对admin库进行描述2.输入命令：$ use admin，你会发现该DB下包含了一个名为system.user的collection，这是用户表，用来存放超级管理员的备注：本文使用的数据库版本是3.4.5，没有默认的admin数据库，但是在执行第二步之后自动创建了一个admin库； 当然也没有默认的system.user表，运行后面的第三步后会自动创建 system.user和system.indexes )3.输入命令：$ db.createUser({user:root&quot;,pwd:&quot;root&quot;,roles:[&quot;root&quot;]})，这里我添加一个超级管理员用户，username为root，password也为root,这里设置其角色为root。先退出 (ctrl+c)程序，测试重启服务后再次连接MongoDB是否需要按提示输入用户名、密码进行操作。4.输入命令：$ use admin5.输入命令：$ show collections，查看该库下所有的表，你会发现，MongoDB并没有提示你输入用户名、密码，原因是，在文章最开始提到了，MongoDB默认设置为无权限访问限制，我们需要先把它设置成为需要权限访问6.从新打开cmd，在mongodb路径的bin目录下，执行$ mongod --dbpath=/data/db --port=27017 --fork --auth --logpath=/var/log/mongo.log7.输入命令：$ use admin8.输入命令：$ show collections，提示：&quot;$err&quot; : &quot;unauthorized db:admin lock type:-1 client:127.0.0.1&quot;显然，已经提示没有权限；用刚才设置的用户名、密码来访问集合9.输入命令：$ db.auth(“root”,”root”)，输出一个结果值为1，说明这个用户匹配上了，如果用户名、密码不对，输出为010.输入命令：$ show collections，将成功显示结果继续操作，可以访问已经存在的数据库，但对于新建的数据库仍然没有权限；继续操作，先退出(ctrl+c)服务11.输入命令：$ mongo TestDB12.输入命令：$ show collections，提示：没有权限13.输入命令：$ db.auth(“root”, “root”)，输出结果为0，说明用户名或者密码有问题，刚刚前面才创建，怎么会不对呢？原因在于：当我们单独访问MongoDB的数据库时，需要权限访问的情况下，用户名密码并非超级管理员，而是该库的system.user表中的用户，注意，我这里说的是单独访问的情况，什么是不单独访问的情况呢？后面再讲。针对上述情况，接下来操作：14.输入命令：$ db.createUser({user: &quot;testdb1u1&quot;, pwd: &quot;xyz123&quot;, roles: [{ role: &quot;dbOwner&quot;, db: &quot;TestDB&quot; }]})，这里设置其角色为dbOwner,仍然提示没有权限，新的数据库使用超级管理员也无法访问，创建用户也没有权限，不过即然设定了超级管理员用户，那它就一定有权限访问所有的库15.输入命令：$ use admin16.输入命令：$ db.auth(“root”, “root”)17.输入命令：$ use TestDB18.输入命令：$ show collections，之后可以利用超级管理员用户访问其它库了，这个就是不单独访问的情况。在上述操作过程中，我们是先进入admin库，再转到其它库来的，admin相当于是一个最高级别用户所在的区域，对数据库操作，需要经过最高级别用户，之后可以创建每个数据库的用户。19.输入命令：$ db.createUser({user: &quot;testdb1u1&quot;, pwd: &quot;xyz123&quot;, roles: [{ role: &quot;dbOwner&quot;, db: &quot;TestDB&quot; }]})，我们给TestDB库添加一个用户，以后每次访问该库，我都使用刚刚创建的这个用户，我们先退出（ctrl+c）20.输入命令：$ mongo TestDB21.输入命令：$ show collections，提示没有权限22.输入命令：$ db.auth(&#39;testdb1u1&#39;,&#39;xyz123&#39;)，输出结果1，用户存在，验证成功23.输入命令：$ show collections，成功显示结果]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Automator添加自己的启动工具]]></title>
    <url>%2F2017%2F11%2F07%2FAutomator%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%90%AF%E5%8A%A8%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[在Mac系统上，Finder选中一个目录，右键菜单并没有“通过Code打开”这个操作。不过我们可以通过Automator自己添加这个操作。这将大大提升将来的操作快捷度。先运行Automator，选择“服务”：然后，执行以下操作：1.在右侧面板选择“服务”收到选定的“文件夹”，位于“Finder.app“，该选项是为了从Finder中接收一个文件夹；2.在左侧面板选择”实用工具“，然后找到”运行Shell脚本“，把它拽到右侧面板里；3.在右侧”运行Shell脚本“的面板里，选择Shell”/bin/bash“，传递输入“作为自变量”，然后修改Shell脚本如下：1234for f in &quot;$@&quot;do open -a &quot;Visual Studio Code&quot; &quot;$f&quot;done保存为“Open With VSCode”后，打开Finder，选中一个文件夹，点击右键，“服务”，就可以看到“Open With VSCode”菜单：]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[恢复stash暂存区clear或者drop的记录]]></title>
    <url>%2F2017%2F11%2F06%2F%E6%81%A2%E5%A4%8Dstash%E6%9A%82%E5%AD%98%E5%8C%BAclear%E6%88%96%E8%80%85drop%E7%9A%84%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[首先输入1$ git fsck --lost-found会看到 一条一条的记录 类似1dangling commit 7010e0447be96627fde29961d420d887533d7796复制 dangling commit 的id（其他的dangling blob不用理会）然后输入1$ git show 7010e0447be96627fde29961d420d887533d7796查看具体内容， 找到你想要的记录记录中会描述日期和摘要，日期是你git stash 的日期，摘要会记录你是在哪一条commit 上进行git stash操作的，类似（WIP on integration-xf: 2e205ac Merge branch ‘release’ into develop）貌似只能一条记录一条记录的查看找到你想要的记录后输入1$ git merge 7010e0447be96627fde29961d420d887533d7796这样就还原了你git stash drop, git stash clear 的内容]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>前端工具</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5项目常见问题及注意事项]]></title>
    <url>%2F2017%2F11%2F04%2FH5%E9%A1%B9%E7%9B%AE%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[Meta基础知识：H5页面窗口自动调整到设备宽度，并禁止用户缩放页面1234567891011121314151617181920212223// 一、HTML页面结构&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; /&gt;// width 设置viewport宽度，为一个正整数，或字符串‘device-width’// height 设置viewport高度，一般设置了宽度，会自动解析出高度，可以不用设置// initial-scale 默认缩放比例，为一个数字，可以带小数// minimum-scale 允许用户最小缩放比例，为一个数字，可以带小数// maximum-scale 允许用户最大缩放比例，为一个数字，可以带小数// user-scalable 是否允许手动缩放// 二、JS动态判断var phoneWidth = parseInt(window.screen.width);var phoneScale = phoneWidth/640;var ua = navigator.userAgent;if (/Android (\d+\.\d+)/.test(ua))&#123; var version = parseFloat(RegExp.$1); if(version&gt;2.3)&#123; document.write(&apos;&lt;meta name=&quot;viewport&quot; content=&quot;width=640, minimum-scale = &apos;+phoneScale+&apos;, maximum-scale = &apos;+phoneScale+&apos;, target-densitydpi=device-dpi&quot;&gt;&apos;); &#125;else&#123; document.write(&apos;&lt;meta name=&quot;viewport&quot; content=&quot;width=640, target-densitydpi=device-dpi&quot;&gt;&apos;); &#125;&#125; else &#123; document.write(&apos;&lt;meta name=&quot;viewport&quot; content=&quot;width=640, user-scalable=no, target-densitydpi=device-dpi&quot;&gt;&apos;);&#125;空白页基本meta标签12345678&lt;!-- 设置缩放 --&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable=no, minimal-ui&quot; /&gt;&lt;!-- 可隐藏地址栏，仅针对IOS的Safari（注：IOS7.0版本以后，safari上已看不到效果） --&gt;&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;&lt;!-- 仅针对IOS的Safari顶端状态条的样式（可选default/black/black-translucent ） --&gt;&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot; /&gt;&lt;!-- IOS中禁用将数字识别为电话号码/忽略Android平台中对邮箱地址的识别 --&gt;&lt;meta name=&quot;format-detection&quot;content=&quot;telephone=no, email=no&quot; /&gt;其他meta标签12345678910111213141516171819202122&lt;!-- 启用360浏览器的极速模式(webkit) --&gt;&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;&lt;!-- 避免IE使用兼容模式 --&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;&lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;&lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt;&lt;!-- 微软的老式浏览器 --&gt;&lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt;&lt;!-- uc强制竖屏 --&gt;&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;&lt;!-- QQ强制竖屏 --&gt;&lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;&lt;!-- UC强制全屏 --&gt;&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;&lt;!-- QQ强制全屏 --&gt;&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;&lt;!-- UC应用模式 --&gt;&lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt;&lt;!-- QQ应用模式 --&gt;&lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt;&lt;!-- windows phone 点击无高光 --&gt;&lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt;常见问题：移动端如何定义字体font-family1234567891011121314151617@ --------------------------------------中文字体的英文名称@ 宋体 SimSun@ 黑体 SimHei@ 微信雅黑 Microsoft Yahei@ 微软正黑体 Microsoft JhengHei@ 新宋体 NSimSun@ 新细明体 MingLiU@ 细明体 MingLiU@ 标楷体 DFKai-SB@ 仿宋 FangSong@ 楷体 KaiTi@ 仿宋_GB2312 FangSong_GB2312@ 楷体_GB2312 KaiTi_GB2312 @@ 说明：中文字体多数使用宋体、雅黑，英文用Helvetica body &#123; font-family: Microsoft Yahei,SimSun,Helvetica; &#125;打电话发短信写邮件怎么实现1234567891011121314151617181920212223242526// 一、打电话&lt;a href=&quot;tel:0755-10086&quot;&gt;打电话给:0755-10086&lt;/a&gt; // 二、发短信，winphone系统无效&lt;a href=&quot;sms:10086&quot;&gt;发短信给: 10086&lt;/a&gt; // 三、写邮件//注：在添加这些功能时，第一个功能以&quot;?&quot;开头，后面的以&quot;&amp;&quot;开头//1.普通邮件&lt;a href=&quot;mailto:863139978@qq.com&quot;&gt;点击我发邮件&lt;/a&gt;//2.收件地址后添加?cc=开头，可添加抄送地址（Android存在兼容问题）&lt;a href=&quot;mailto:863139978@qq.com?cc=zhangqian0406@yeah.net&quot;&gt;点击我发邮件&lt;/a&gt;//3.跟着抄送地址后，写上&amp;bcc=,可添加密件抄送地址（Android存在兼容问题）&lt;a href=&quot;mailto:863139978@qq.com?cc=zhangqian0406@yeah.net&amp;bcc=384900096@qq.com&quot;&gt;点击我发邮件&lt;/a&gt;//4.包含多个收件人、抄送、密件抄送人，用分号(;)隔开多个邮件人的地址&lt;a href=&quot;mailto:863139978@qq.com;384900096@qq.com&quot;&gt;点击我发邮件&lt;/a&gt;//5.包含主题，用?subject=&lt;a href=&quot;mailto:863139978@qq.com?subject=邮件主题&quot;&gt;点击我发邮件&lt;/a&gt;//6.包含内容，用?body=;如内容包含文本，使用%0A给文本换行 &lt;a href=&quot;mailto:863139978@qq.com?body=邮件主题内容%0A腾讯诚信%0A期待您的到来&quot;&gt;点击我发邮件&lt;/a&gt;//7.内容包含链接，含http(s)://等的文本自动转化为链接&lt;a href=&quot;mailto:863139978@qq.com?body=http://www.baidu.com&quot;&gt;点击我发邮件&lt;/a&gt;//8.内容包含图片（PC不支持）&lt;a href=&quot;mailto:863139978@qq.com?body=&lt;img src=&apos;images/1.jpg&apos; /&gt;&quot;&gt;点击我发邮件&lt;/a&gt;//9.完整示例&lt;a href=&quot;mailto:863139978@qq.com;384900096@qq.com?cc=zhangqian0406@yeah.net&amp;bcc=993233461@qq.com&amp;subject=[邮件主题]&amp;body=腾讯诚邀您参与%0A%0Ahttp://www.baidu.com%0A%0A&lt;img src=&apos;images/1.jpg&apos; /&gt;&quot;&gt;点击我发邮件&lt;/a&gt;移动端touch事件（区分webkit和winphone）/ 当用户手指放在移动设备在屏幕上滑动会触发的touch事件 /// 以下支持webkittouchstart——当手指触碰屏幕时候发生。不管当前有多少只手指touchmove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用event的preventDefault()可以阻止默认情况的发生：阻止页面滚动touchend——当手指离开屏幕时触发touchcancel——系统停止跟踪触摸时候会触发。例如在触摸过程中突然页面alert()一个提示框，此时会触发该事件，这个事件比较少用//TouchEvent说明：touches：屏幕上所有手指的信息targetTouches：手指在目标区域的手指信息changedTouches：最近一次触发该事件的手指信息touchend时，touches与targetTouches信息会被删除，changedTouches保存的最后一次的信息，最好用于计算手指信息//参数信息(changedTouches[0])clientX、clientY在显示区的坐标target：当前元素//事件响应顺序ontouchstart &gt; ontouchmove &gt; ontouchend &gt; onclick// 以下支持winphone 8MSPointerDown——当手指触碰屏幕时候发生。不管当前有多少只手指MSPointerMove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用css的html{-ms-touch-action: none;}可以阻止默认情况的发生：阻止页面滚动MSPointerUp——当手指离开屏幕时触发移动端click屏幕产生200-300ms的延时响应说明：移动设备上的web网页是有300ms延迟的，玩玩会造成按钮点击延迟甚至是点击失效。以下是历史原因，来源一个公司内一个同事的分享：2007年苹果发布首款iphone上IOS系统搭载的safari为了将适用于PC端上大屏幕的网页能比较好的展示在手机端上，使用了双击缩放(double tap to zoom)的方案，比如你在手机上用浏览器打开一个PC上的网页，你可能在看到页面内容虽然可以撑满整个屏幕，但是字体、图片都很小看不清，此时可以快速双击屏幕上的某一部分，你就能看清该部分放大后的内容，再次双击后能回到原始状态。双击缩放是指用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。原因就出在浏览器需要如何判断快速点击上，当用户在屏幕上单击某一个元素时候，例如跳转链接 &lt;a href=&quot;#&quot;&gt;&lt;/a&gt;，此处浏览器会先捕获该次单击，但浏览器不能决定用户是单纯要点击链接还是要双击该部分区域进行缩放操作，所以，捕获第一次单击后，浏览器会先Hold一段时间t，如果在t时间区间里用户未进行下一次点击，则浏览器会做单击跳转链接的处理，如果t时间里用户进行了第二次单击操作，则浏览器会禁止跳转，转而进行对该部分区域页面的缩放操作。那么这个时间区间t有多少呢？在IOS safari下，大概为300毫秒。这就是延迟的由来。造成的后果用户纯粹单击页面，页面需要过一段时间才响应，给用户慢体验感觉，对于web开发者来说是，页面js捕获click事件的回调函数处理，需要300ms后才生效，也就间接导致影响其他业务逻辑的处理。解决方案：fastclick可以解决在手机上点击事件的300ms延迟zepto的touch模块，tap事件也是为了解决在click的延迟问题Rentina显示屏原理及设计方案说明：retina屏是一种具备超高像素密度的液晶屏，同样大小的屏幕上显示的像素点由1个变为多个，如在同样带下的屏幕上，苹果设备的retina显示屏中，像素点1个变为4个。在高清显示屏中的位图被放大，图片会变得模糊，因此移动端的视觉稿通常会设计为传统PC的2倍。那么，前端的应对方案是：设计稿切出来的图片长宽保证为偶数，并使用backgroud-size把图片缩小为原来的1/2//例如图片宽高为：200px*200px，那么写法如下1.css&#123;width:100px;height:100px;background-size:100px 100px;&#125;//其它元素的取值为原来的1/2，例如视觉稿40px的字体，使用样式的写法为20px1.css&#123;font-size:20px&#125;//image-set设计Rentina背景图image-set,webkit私有属性，也是CSS4的属性，为解决Rentina屏幕下的图像而生。123456.css &#123; background: url(images/bg.jpg) no-repeat center; background: -webkit-image-set( url(images/bg.jpg) 1x, //支持image-set普通屏 url(images/bg-2x.jpg) 2x); //支持image-set的Rentinan&#125;点击元素产生背景或边框怎么去掉ios用户点击一个链接，会出现一个半透明灰色遮罩, 如果想要禁用，可设置-webkit-tap-highlight-color的alpha值为0去除灰色半透明遮罩；android用户点击一个链接，会出现一个边框或者半透明灰色遮罩, 不同生产商定义出来额效果不一样，可设置-webkit-tap-highlight-color的alpha值为0去除部分机器自带的效果；winphone系统,点击标签产生的灰色半透明背景，能通过设置&lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt;去掉；特殊说明：有些机型去除不了，如小米2。对于按钮类还有个办法，不使用a或者input标签，直接用div标签12345678a,button,input,textarea &#123; -webkit-tap-highlight-color: rgba(0,0,0,0); -webkit-user-modify:read-write-plaintext-only; //-webkit-user-modify有个副作用，就是输入法不再能够输入多个字符&#125;// 也可以 * &#123; -webkit-tap-highlight-color: rgba(0,0,0,0); &#125;//winphone下&lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt;美化表单元素一、使用appearance改变webkit浏览器的默认外观1input,select &#123; -webkit-appearance:none; appearance: none; &#125;二、winphone下，使用伪元素改变表单元素默认外观1.禁用select默认箭头，::-ms-expand修改表单控件下拉箭头，设置隐藏并使用背景图片来修饰1select::-ms-expand &#123; display:none; &#125;2.禁用radio和checkbox默认样式，::-ms-check修改表单复选框或单选框默认图标，设置隐藏并使用背景图片来修饰12input[type=radio]::-ms-check,input[type=checkbox]::-ms-check &#123; display:none; &#125;3.禁用pc端表单输入框默认清除按钮，::-ms-clear修改清除按钮，设置隐藏并使用背景图片来修饰123input[type=text]::-ms-clear,input[type=tel]::-ms-clear,input[type=number]::-ms-clear &#123; display:none; &#125;移动端字体单位font-size选择px还是rem如需适配多种移动设备，建议使用rem。以下为参考值：123html &#123; font-size: 62.5%; &#125; //10*16 = 62.5%//设置12px字体 这里注意在rem前要加上对应的px值，解决不支持rem的浏览器的兼容问题，做到优雅降级body &#123; font-size:12px; font-size:1.2rem; &#125;超实用的CSS样式去掉webkit的滚动条—— display: none;//其他参数::-webkit-scrollba //滚动条整体部分::-webkit-scrollbar-thumb //滚动条内的小方块::-webkit-scrollbar-track //滚动条轨道::-webkit-scrollbar-button //滚动条轨道两端按钮::-webkit-scrollbar-track-piece //滚动条中间部分，内置轨道::-webkit-scrollbar-corner //边角，两个滚动条交汇处::-webkit-resizer //两个滚动条的交汇处上用于通过拖动调整元素大小的小控件1234567891011121314151617181920212223// 禁止长按链接与图片弹出菜单a,img &#123; -webkit-touch-callout: none &#125; // 禁止ios和android用户选中文字html,body &#123;-webkit-user-select:none; user-select: none; &#125; // 改变输入框placeholder的颜色值::-webkit-input-placeholder &#123; /* WebKit browsers */color: #999; &#125;:-moz-placeholder &#123; /* Mozilla Firefox 4 to 18 */color: #999; &#125;::-moz-placeholder &#123; /* Mozilla Firefox 19+ */color: #999; &#125;:-ms-input-placeholder &#123; /* Internet Explorer 10+ */color: #999; &#125;input:focus::-webkit-input-placeholder&#123; color:#999; &#125; // android上去掉语音输入按钮input::-webkit-input-speech-button &#123;display: none&#125; // 阻止windows Phone的默认触摸事件/*说明：winphone下默认触摸事件事件使用e.preventDefault是无效的，可通过样式来禁用，如：*/html &#123; -ms-touch-action:none; &#125; //禁止winphone默认触摸事件取消input在ios下，输入的时候英文首字母的默认大写1&lt;input autocapitalize=&quot;off&quot; autocorrect=&quot;off&quot; /&gt;手机拍照和上传图片123//IOS有拍照、录像、选取本地图片功能，部分Android只有选择本地图片功能。Winphone不支持&lt;input type=&quot;file&quot; accept=&quot;images/*&quot; /&gt;&lt;input type=&quot;file&quot; accept=&quot;video/*&quot; /&gt;屏幕旋转的事件和样式1234567891011121314//JS处理function orientInit()&#123; var orientChk = document.documentElement.clientWidth &gt; document.documentElement.clientHeight?&apos;landscape&apos;:&apos;portrait&apos;; if(orientChk ==&apos;lapdscape&apos;)&#123; //这里是横屏下需要执行的事件 &#125;else&#123; //这里是竖屏下需要执行的事件 &#125;&#125; orientInit();window.addEventListener(&apos;onorientationchange&apos; in window?&apos;orientationchange&apos;:&apos;resize&apos;, function()&#123; setTimeout(orientInit, 100);&#125;,false)12345//CSS处理//竖屏时样式@media all and (orientation:portrait)&#123; &#125;//横屏时样式@media all and (orientation:landscape)&#123; &#125;audio元素和video元素在ios和andriod中无法自动播放12345678910111213141516171819//音频，写法一&lt;audio src=&quot;music/bg.mp3&quot; autoplay loop controls&gt;你的浏览器还不支持哦&lt;/audio&gt; //音频，写法二&lt;audio controls=&quot;controls&quot;&gt; &lt;source src=&quot;music/bg.ogg&quot; type=&quot;audio/ogg&quot;&gt;&lt;/source&gt; &lt;source src=&quot;music/bg.mp3&quot; type=&quot;audio/mpeg&quot;&gt;&lt;/source&gt; 优先播放音乐bg.ogg，不支持在播放bg.mp3&lt;/audio&gt; //JS绑定自动播放（操作window时，播放音乐）$(window).one(&apos;touchstart&apos;, function()&#123; music.play();&#125;) //微信下兼容处理document.addEventListener(&quot;WeixinJSBridgeReady&quot;, function () &#123; music.play();&#125;, false);小结1.audio元素的autoplay属性在IOS及Android上无法使用，在PC端正常2.audio元素没有设置controls时，在IOS及Android会占据空间大小，而在PC端Chrome是不会占据任何空间重力感应事件123456789101112131415161718192021222324// 运用HTML5的deviceMotion，调用重力感应事件if(window.DeviceMotionEvent)&#123; document.addEventListener(&apos;devicemotion&apos;, deviceMotionHandler, false)&#125; var speed = 30;var x = y = z = lastX = lastY = lastZ = 0;function deviceMotionHandler(eventData)&#123; var acceleration = event.accelerationIncludingGravity; x = acceleration.x; y = acceleration.y; z = acceleration.z; if(Math.abs(x-lastX)&gt;speed || Math.abs(y-lastY)&gt;speed || Math.abs(z-lastZ)&gt;speed )&#123; //这里是摇动后要执行的方法 yaoAfter(); &#125; lastX = x; lastY = y; lastZ = z;&#125; function yaoAfter()&#123; //do something&#125;微信浏览器用户调整字体大小后页面矬了，怎么阻止用户调整12345678910111213141516//以下代码可使Android机页面不再受用户字体缩放强制改变大小，但是会有1S左右延时，期间可以考虑loading来处理if (typeof(WeixinJSBridge) == &quot;undefined&quot;) &#123; document.addEventListener(&quot;WeixinJSBridgeReady&quot;, function (e) &#123; setTimeout(function()&#123; WeixinJSBridge.invoke(&apos;setFontSizeCallback&apos;, &#123; &apos;fontSize&apos;:0&#125;, function(res)&#123; alert(JSON.stringify(res)); &#125;) &#125;, 0) &#125;);&#125;else&#123; setTimeout(function()&#123; WeixinJSBridge.invoke(&apos;setFontSizeCallback&apos;, &#123; &apos;fontSize&apos;:0&#125;, function(res)&#123; alert(JSON.stringify(res)); &#125;) &#125;, 0) &#125;12//IOS下可使用 -webkit-text-size-adjust禁止用户调整字体大小body &#123; -webkit-text-size-adjust:100%!important; &#125;最好的解决方案：最好使用rem或百分比布局定位的坑fixed定位1.ios下fixed元素容易定位出错，软键盘弹出时，影响fixed元素定位2.android下fixed表现要比iOS更好，软键盘弹出时，不会影响fixed元素定位3.ios4下不支持position:fixed解决方案：使用Iscroll，如：123456789101112131415161718192021222324252627&lt;div id=&quot;wrapper&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; ..... &lt;/ul&gt;&lt;/div&gt;&lt;script src=&quot;iscroll.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var myscroll; function loaded()&#123; myscroll=new iScroll(&quot;wrapper&quot;); &#125; window.addEventListener(&quot;DOMContentLoaded&quot;,loaded,false);&lt;/script&gt; //position定位//Android下弹出软键盘弹出时，影响absolute元素定位//解决方案:var ua = navigator.userAgent.indexOf(&apos;Android&apos;);if(ua&gt;-1)&#123; $(&apos;.ipt&apos;).on(&apos;focus&apos;, function()&#123; $(&apos;.css&apos;).css(&#123;&apos;visibility&apos;:&apos;hidden&apos;&#125;) &#125;).on(&apos;blur&apos;, function()&#123; $(&apos;.css&apos;).css(&#123;&apos;visibility&apos;:&apos;visible&apos;&#125;) &#125;)&#125;播放视频不全屏12345678&lt;!--1.ios7+支持自动播放2.支持Airplay的设备（如：音箱、Apple TV)播放x-webkit-airplay=&quot;true&quot; 3.播放视频不全屏webkit-playsinline=&quot;true&quot; --&gt;&lt;video x-webkit-airplay=&quot;true&quot; webkit-playsinline=&quot;true&quot; preload=&quot;auto&quot; autoplay src=&quot;http://&quot;&gt;&lt;/video&gt;JS判断设备12345678910111213function deviceType()&#123; var ua = navigator.userAgent; var agent = [&quot;Android&quot;, &quot;iPhone&quot;, &quot;SymbianOS&quot;, &quot;Windows Phone&quot;, &quot;iPad&quot;, &quot;iPod&quot;]; for(var i=0; i&lt;len,len = agent.length; i++)&#123; if(ua.indexOf(agent[i])&gt;0)&#123; break; &#125; &#125;&#125;deviceType();window.addEventListener(&apos;resize&apos;, function()&#123; deviceType();&#125;)JS判断微信浏览器12345678function isWeixin()&#123; var ua = navigator.userAgent.toLowerCase(); if(ua.match(/MicroMessenger/i)==&apos;micromessenger&apos;)&#123; return true; &#125;else&#123; return false; &#125;&#125;android 2.3 bug1.@-webkit-keyframes 需要以0%开始100%结束，0%的百分号不能去掉2.after和before伪类无法使用动画animation3.border-radius不支持%单位，如要兼容，可以给 radius 设置一下较大的值4.translate百分比的写法和scale在一起会导致失效，例如：-webkit-transform: translate(-50%,-50%) scale(-0.5, 1)android 4.x bug1.三星 Galaxy S4中自带浏览器不支持border-radius缩写2.同时设置border-radius和背景色的时候，背景色会溢出到圆角以外部分3.部分手机(如三星)，a链接支持鼠标:visited事件，也就是说链接访问后文字变为紫色4.android无法同时播放多音频audio消除transition闪屏12345.css &#123; -webkit-transform-style: preserve-3d; -webkit-backface-visibility: hidden; -webkit-perspective: 1000;&#125;开启硬件加速目前，像 Chrome/Filefox/Safari/IE9+ 以及最新版本 Opera 都支持硬件加速，当检测到某个DOM元素应用了某些CSS规则时就会自动开启，从而解决页面闪白，保证动画流畅。123456.css &#123; -webkit-transform: translate3d(0,0,0); -moz-transform: translate3d(0,0,0); -ms-transform: translate3d(0,0,0); transform: translate3d(0,0,0);&#125;渲染优化1.禁止使用iframe（阻塞父文档onload事件）2.禁止使用gif图片实现loading效果（降低CPU消耗，提升渲染性能）使用CSS3代码代替JS动画；开启GPU加速；使用base64位编码图片(不小图而言，大图不建议使用)对于一些小图标，可以使用base64位编码，以减少网络请求。但不建议大图使用，比较耗费CPU。小图标优势在于：1.减少HTTP请求； 2.避免文件跨域； 3.修改及时生效；]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>HTML</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UA判断]]></title>
    <url>%2F2017%2F10%2F01%2Fis_weixinis_iOS%20is_android%2F</url>
    <content type="text"><![CDATA[is_weixin12345678function is_weixin()&#123; var ua = navigator.userAgent.toLowerCase(); if(ua.match(/MicroMessenger/i)==&quot;micromessenger&quot;) &#123; return 1; &#125; else &#123; return 2; &#125;&#125;Android or iOS1234567&lt;script type=&quot;text/javascript&quot;&gt;var u = navigator.userAgent;var isAndroid = u.indexOf(&apos;Android&apos;) &gt; -1 || u.indexOf(&apos;Adr&apos;) &gt; -1; //android终端var isiOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端alert(&apos;是否是Android：&apos;+isAndroid);alert(&apos;是否是iOS：&apos;+isiOS);&lt;/script&gt;终端1234567891011121314151617181920var browser=&#123; versions:function()&#123; var u = navigator.userAgent, app = navigator.appVersion; return &#123; trident: u.indexOf(&apos;Trident&apos;) &gt; -1, //IE内核 presto: u.indexOf(&apos;Presto&apos;) &gt; -1, //opera内核 webKit: u.indexOf(&apos;AppleWebKit&apos;) &gt; -1, //苹果、谷歌内核 gecko: u.indexOf(&apos;Gecko&apos;) &gt; -1 &amp;&amp; u.indexOf(&apos;KHTML&apos;) == -1,//火狐内核 mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端 ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端 android: u.indexOf(&apos;Android&apos;) &gt; -1 || u.indexOf(&apos;Adr&apos;) &gt; -1, //android终端 iPhone: u.indexOf(&apos;iPhone&apos;) &gt; -1 , //是否为iPhone或者QQHD浏览器 iPad: u.indexOf(&apos;iPad&apos;) &gt; -1, //是否iPad webApp: u.indexOf(&apos;Safari&apos;) == -1, //是否web应该程序，没有头部与底部 weixin: u.indexOf(&apos;MicroMessenger&apos;) &gt; -1, //是否微信 （2015-01-22新增） qq: u.match(/\sQQ/i) == &quot; qq&quot; //是否QQ &#125;; &#125;(), language:(navigator.browserLanguage || navigator.language).toLowerCase()&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生日快乐，我的祖国]]></title>
    <url>%2F2017%2F10%2F01%2F%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90%E7%A5%96%E5%9B%BD%2F</url>
    <content type="text"><![CDATA[神州大地繁花似锦，祖国长空乐曲如潮。在这美好日子里，让我们用最真挚的祝福：祖国繁荣昌盛！https://weibo.com/tv/v/Fi0hv1pD4?fid=1034:45f112bf7ee6bde62ed9fe9735d0574e&amp;ssl_rnd=1509627260.9088]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Amazing China</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令]]></title>
    <url>%2F2017%2F07%2F07%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1$ git init // 把当前的目录变成可以管理的git仓库，生成隐藏.git文件。1$ git add XX // 把xx文件添加到暂存区去。1$ git commit –m “XX” // 提交文件 –m 后面的是注释。1$ git status // 查看仓库状态1$ git diff XX // 查看XX文件修改了那些内容1$ git log // 查看历史记录1$ git reset --hard HEAD^ 或者 git reset --hard HEAD~ // 回退到上一个版本 (如果想回退到100个版本，使用git reset –hard HEAD~100 )1$ git reflog // 查看历史记录的版本号id1$ git checkout -- XX // 把XX文件在工作区的修改全部撤销。1$ git rm XX // 删除XX文件1$ git remote add origin https://github.com/tugenhua0707/testgit // 关联一个远程库1$ git push –u(第一次要用-u 以后不需要) origin master // 把当master分支推送到远程库1$ git clone https://github.com/tugenhua0707/testgit // 从远程库中克隆1$ git checkout –b dev // 创建dev分支 并切换到dev分支上1$ git branch // 查看当前所有的分支1$ git checkout master // 切换回master分支1$ git merge dev // 在当前的分支上合并dev分支$ git branch –d dev // 删除dev分支1$ git branch name // 创建分支1$ git stash // 把当前的工作隐藏起来 等以后恢复现场后继续工作1$ git stash list // 查看所有被隐藏的文件列表1$ git stash apply // 恢复被隐藏的文件，但是内容不删除1$ git stash drop // 删除文件1$ git stash pop // 恢复文件的同时 也删除文件1$ git remote // 查看远程库的信息1$ git remote –v // 查看远程库的详细信息1$ git push origin master // Git会把master分支推送到远程库对应的远程分支上1$ git push origin 本地分支:远程分支 // 推送本地分支到远程多人协作工作模式一般是这样的：首先，可以试图用git push origin branch-name推送自己的修改.如果推送失败，则因为远程分支比你的本地更新早，需要先用git pull试图合并。如果合并有冲突，则需要解决冲突，并在本地提交。再用git push origin branch-name推送。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>前端工具</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pm2-基本使用方法]]></title>
    <url>%2F2017%2F06%2F09%2Fpm2-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[目前Nodejs开发中有很多痛点，其中有一个是修改完代码以后需要我们重启服务才能看到效果。这样一次次的杀进程、重启，杀进程、重启很让人头大。程序员是最痛恨重复工作的物种，之前有了解过的同学可能知道forever。forever可以帮我们解决上面的问题，通过对资源变化的检测做到变化后自动重启。开发阶段我们使用node file.js来启动另外由于Nodejs的单线程，任何异常都会导致整个服务中断，这对于生产上长时间提供服务的程序来讲是不可以的，forever可以帮我们在异常后重启，保证服务一直在线，我想这也就是它名字的由来吧。但我想说的是forever不够“高！大！上！”。接下来我要介绍一个足够高大上的神器– pm2。简介pm2=P(rocess) M(anager)2，是可以用于生产环境的Nodejs的进程管理工具，并且它内置一个负载均衡。它不仅可以保证服务不会中断一直在线，并且提供0秒reload功能，还有其他一系列进程管理、监控功能。并且使用起来非常简单。下面我将把我的使用过程分享出来，Nodejs应用是一个基于Express 4.x的应用，名称是项目。安装环境清单：macOS | node v5.0.0 | npm 3.3.6全局安装pm21$ npm install pm2 -g更新1$ pm2 update启动以前启动项目是利用package.json的scripts来实现的，只需要执行npm run start就可以启动，配置如下：1234&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;node ./bin/www&quot;, &quot;debug&quot;: &quot;node debug ./bin/www&quot; &#125;,使用pm2我们可以在start处配置成 pm2 ./bin/www,命令后面支持加参数来实现watch、cluster多进程模式等功能。我不太喜欢一大串的命令，于是我使用了配置文件的方式。在项目的根目录，我创建了一个processes.json配置文件，配置文件内容如下，注释写的也很清楚了123456789101112131415161718&#123; &quot;apps&quot; : [&#123; &quot;name&quot; : &quot;项目&quot;, //名称 &quot;script&quot;: &quot;./bin/www&quot;, //程序入库 &quot;cwd&quot;: &quot;./&quot;, //根目录 &quot;watch&quot;:[ &quot;bin&quot;, &quot;common&quot;, &quot;configs&quot;, &quot;public&quot;, &quot;routes&quot;, &quot;views&quot; ],//需要监控的目录 &quot;error_file&quot;:&quot;./logs/app-err.log&quot;,//错误输出日志 &quot;out_file&quot;:&quot;./logs/app-out.log&quot;, //日志 &quot;log_date_format&quot;:&quot;YYYY-MM-DD HH:mm Z&quot; //日期格式 &#125;]&#125;随后，我在package.json中增加了一条1&quot;pm2&quot;: &quot;pm2 start processes.json&quot;在启动就直接输入如下命令就好：1$ npm run pm2就启动成功了，然后我们就可以关掉这个窗口了，服务不会因此停止。管理和监控启动成功的界面会展示App name和id，这两个值很重要。当然这两个值都可以在processes.json配置文件进行配置。打开命令行，在任何路径下，输入1$ pm2 list就能看到启动时的图表界面，方便我们查看所有通过pm2管理的Nodejs服务。输入,下面命令配合id或者name可以查看某一个进程的详细信息12$ pm2 show 项目 或者$ pm2 show 0内容涉及重启次数、运行时间、脚本路径、参数、日志路径、运行模式等等信息输入1$ pm2 monit停止、重启等命令1234567$ pm2 stop [app-name|id] #停止某一个进程，可以使用app-name或者id$ pm2 stop all #停止所有进程 $ pm2 restart all #重启所有的进程 $ pm2 delete [app-name|id]#删除并停止进程$ pm2 delete all #删除并停止所有进程可以进一步查看每一个服务的cpu、内存动态占用情况。日志监控如果你一直使用 tail -f log_file.log log_error.log 来查看日志，你可能会爱上下面的这个功能。12$ pm2 logs$ pm2 logs [app-name]我们可以实时查看全部进程的日志，或者只查看某一个。我们甚至可以使用json格式查看日志。1$ pm2 logs --jsonWeb API如果你不仅仅想监控被pm2管理的进程，还需要监控进程所运行的机器的信息，你可以使用下面这个API1$ pm2 webpm2会启动一个叫做pm2-http-interface的进程提供web服务。你打开浏览器输入 http：//127.0.0.1:9615 ，是不是被看到的结果惊艳到了。pm2提供的web api通过json输出了很多信息。拿出你的想象力，我们可以开发一个应用来调用此api，就可以开发出一个图形界面的监控软件了。。。其它pm2的优势和功能还不止这些，后续还会有文章详述更多高级的用法，比如进程恢复、图形界面，模块，甚至的功能开发。最重要的优势我想就是它的稳定性了，pm2的功能全部通过了测试，有超过1000个测试。同时提供Windows、MacOSX（OSX）、Linux的稳定版本。PayPal、微软、IBM等等大厂都在使用。我们已经有充分的理由把它应用到生产环境上。转自 httdp://web.jobbole.com/89255/]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>PM2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用正则表达式]]></title>
    <url>%2F2017%2F03%2F08%2F%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Js代码123var reg = /^(\d&#123;1,4&#125;)(-|\/)(\d&#123;1,2&#125;)\2(\d&#123;1,2&#125;)$/; var r = fieldValue.match(reg); if(r==null)alert(&apos;Date format error!&apos;);下面是整理的，在前端开发中经常使用到的20个正则表达式。校验密码强度密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。1^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$校验中文字符串仅能是中文。1^[\u4e00-\u9fa5]&#123;0,&#125;$由数字、26个英文字母或下划线组成的字符串1^\w+$校验E-Mail 地址同密码一样，下面是E-mail地址合规性的正则检查语句。1[\w!#$%&amp;&apos;*+/=?^_`&#123;|&#125;~-]+(?:\.[\w!#$%&amp;&apos;*+/=?^_`&#123;|&#125;~-]+)*@(?:[\w](?:[\w-]*[\w])?\.)+[\w](?:[\w-]*[\w])?校验身份证号码下面是身份证号码的正则校验。15 或 18位。15位：1^[1-9]\d&#123;7&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d&#123;3&#125;$18位：1^[1-9]\d&#123;5&#125;[1-9]\d&#123;3&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d&#123;3&#125;([0-9]|X)$校验日期“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。1^(?:(?!0000)[0-9]&#123;4&#125;-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]&#123;2&#125;(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$校验金额金额校验，精确到2位小数。1^[0-9]+(.[0-9]&#123;2&#125;)?$校验手机号下面是国内 13、15、18开头的手机号正则表达式。（可根据目前国内收集号扩展前两位开头号码）1^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d&#123;8&#125;$判断IE的版本IE目前还没被完全取代，很多页面还是需要做版本兼容，下面是IE版本检查的表达式。1^.*MSIE [5-8](?:\.[0-9]+)?(?!.*Trident\/[5-9]\.0).*$校验IP-v4地址IP4 正则语句。1\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b校验IP-v6地址IP6 正则语句。1(([0-9a-fA-F]&#123;1,4&#125;:)&#123;7,7&#125;[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,7&#125;:|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,6&#125;:[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,5&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,2&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,3&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,3&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,2&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,5&#125;|[0-9a-fA-F]&#123;1,4&#125;:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,6&#125;)|:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,7&#125;|:)|fe80:(:[0-9a-fA-F]&#123;0,4&#125;)&#123;0,4&#125;%[0-9a-zA-Z]&#123;1,&#125;|::(ffff(:0&#123;1,4&#125;)&#123;0,1&#125;:)&#123;0,1&#125;((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;:((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9]))检查URL的前缀应用开发中很多时候需要区分请求是HTTPS还是HTTP，通过下面的表达式可以取出一个url的前缀然后再逻辑判断。123if (!s.match(/^[a-zA-Z]+:\/\//)) &#123; s = &apos;http://&apos; + s; &#125;提取URL链接下面的这个表达式可以筛选出一段文本中的URL。1^(f|ht)&#123;1&#125;(tp|tps):\/\/([\w-]+\.)+[\w-]+(\/[\w- ./?%&amp;=]*)?文件路径及扩展名校验验证windows下文件路径和扩展名（下面的例子中为.txt文件）1^([a-zA-Z]\:|\\)\\([^\\]+\\)*[^\/:*?&quot;&lt;&gt;|]+\.txt(l)?$提取Color Hex Codes有时需要抽取网页中的颜色代码，可以使用下面的表达式。1^#([A-Fa-f0-9]&#123;6&#125;|[A-Fa-f0-9]&#123;3&#125;)$提取网页图片假若你想提取网页中所有图片信息，可以利用下面的表达式。1\&lt; *[img][^\\&gt;]*[src] *= *[\&quot;\&apos;]&#123;0,1&#125;([^\&quot;\&apos;\ &gt;]*)提取页面超链接提取html中的超链接。12(&lt;a\s*(?!.*\brel=)[^&gt;]*)(href=&quot;https?:\/\/)((?!(?:(?:www\.)?&apos;.implode(&apos;|(?:www\.)?&apos;, $follow_list).&apos;))[^&quot;]+)&quot;((?!.*\brel=)[^&gt;]*)(?:[^&gt;]*)&gt; &lt;/a\s*(?!.*\brel=)[^&gt;查找CSS属性通过下面的表达式，可以搜索到相匹配的CSS属性。1^\s*[a-zA-Z\-]+\s*[:]&#123;1&#125;\s[a-zA-Z0-9\s.#]+[;]&#123;1&#125;抽取注释如果你需要移除HMTL中的注释，可以使用如下的表达式。1&lt;!--(.*?)--&gt;匹配HTML标签通过下面的表达式可以匹配出HTML中的标签属性。1&lt;\/?\w+((\s+\w+(\s*=\s*(?:&quot;.*?&quot;|&apos;.*?&apos;|[\^&apos;&quot;&gt;\s]+))?)+\s*|\s*)\/?&gt;非中文1/[^\u4e00-\u9fa5|,]+/]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime text 3 安装 install package]]></title>
    <url>%2F2017%2F03%2F06%2FsublimeText3%E5%AE%89%E8%A3%85InstallPackage%2F</url>
    <content type="text"><![CDATA[打开Sublime Text3 ，按Ctrl+`（和qq输入法快捷切换冲突，可以修改qq的输入法切换热键）复制粘黏以下代码添加至命令行，然后回车1$ import urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ','%20')).read())重启Sublime Text 3]]></content>
      <tags>
        <tag>前端工具</tag>
        <tag>Sublime Text3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打开Mac OSX原生的NTFS功能]]></title>
    <url>%2F2017%2F03%2F05%2FOSX%E5%8E%9F%E7%94%9F%E7%9A%84NTFS%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[很多同学都会为如何在Mac下写入NTFS格式的磁盘而感到困惑，因为默认情况下，把一个NTFS格式的磁盘插入到Mac里，是只能读不能写的。用起来肯定很郁闷，很多同学也因此把移动硬盘分成了双分区，一个NTFS，一个HFS。其实在Mac下完全是可以写NTFS磁盘的。一种十分简单的方法是用第三方工具，Paragon NTFS for MAC。使用这种工具，虽然说是简单了，可是麻烦事也不少，一来是这个工具是要收费的，当然有破解版，不过破解版里有没有被植入什么，那就没有人知道了，二是这个工具本身就不怎么稳定，容易丢数据不说，每次OSX一更新，必须得等软件更新后才能用，总之，用起来不放心啊。其实呢，大家并不需要困惑，OSX其实原生就支持NTFS，最早在OSX 10.5的时候，是可以直接写入NTFS的盘的，后来由于微软的限制，把这个功能给屏蔽了，我们可以通过命令行手动打开这个选项。第一步，当然是插上磁盘啦。可以从finder或者使用以下命令查看到磁盘的Volume Name:diskutil list/dev/disk0#: TYPE NAME SIZE IDENTIFIER 0: GUID_partition_scheme *128.0 GB disk0 1: EFI EFI 209.7 MB disk0s1 2: Apple_CoreStorage 127.7 GB disk0s2 3: Apple_Boot Boot OS X 134.2 MB disk0s3 /dev/disk1#: TYPE NAME SIZE IDENTIFIER 0: GUID_partition_scheme *500.1 GB disk1 1: EFI EFI 209.7 MB disk1s1 2: Apple_CoreStorage 499.2 GB disk1s2 3: Apple_Boot Boot OS X 650.0 MB disk1s3 /dev/disk2#: TYPE NAME SIZE IDENTIFIER 0: Apple_HFS Macintosh HD *621.4 GB disk2 /dev/disk3#: TYPE NAME SIZE IDENTIFIER 0: FDisk_partition_scheme *1.0 TB disk3 1: Windows_NTFS FreeAgent GoFlex Drive 1.0 TB disk3s1 可以看到，我的 Volume Name 是FreeAgent GoFlex Drive。紧接着更新 /etc/fstab文件1$ sudo vim /etc/fstab把以下内容写入进去LABEL=FreeAgent\040GoFlex\040Drive none ntfs rw,auto,nobrowse下面来依次解释一下，其中的\040的意思是代替空格键，因为我的Volume Name是有空格的，所以必须把这个空格给转义了。后面的Ntfs rw表示把这个分区挂载为可读写的ntfs格式，最后nobrowse非常重要，因为这个代表了在finder里不显示这个分区，这个选项非常重要，如果不打开的话挂载是不会成功的。编辑好以后重新插入磁盘，就能识别到了，但是这个时候有了一个最大的问题，因为这个分区在finder里不显示了，那么我们要怎么找到它呢，总不能一直用命令行把。解决办法其实很简单，因为这个分区是挂/Volumes下的，我们把这个目录在桌面做一个快捷方式就行了。1$ sudo ln -s /Volumes ~/Desktop/Volumes然后我们能在桌面找到点开以后就能找到磁盘了用这种方法打开的是系统原生的ntfs功能，稳定实用，比第三方工具要好用的多了。]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取手机号位置api]]></title>
    <url>%2F2017%2F02%2F02%2F%E8%8E%B7%E5%8F%96%E6%89%8B%E6%9C%BA%E5%8F%B7%E4%BD%8D%E7%BD%AEapi%2F</url>
    <content type="text"><![CDATA[淘宝网API地址： http://tcc.taobao.com/cc/json/mobile_tel_segment.htm?tel=15850781443参数：tel：手机号码返回：JSON拍拍API地址： http://virtual.paipai.com/extinfo/GetMobileProductInfo?mobile=15850781443&amp;amount=10000&amp;callname=getPhoneNumInfoExtCallback参数：mobile：手机号码callname：回调函数amount：未知（必须）返回：JSON财付通API地址： http://life.tenpay.com/cgi-bin/mobile/MobileQueryAttribution.cgi?chgmobile=15850781443参数：chgmobile：手机号码返回：xml百付宝API地址： https://www.baifubao.com/callback?cmd=1059&amp;callback=phone&amp;phone=15850781443参数：phone：手机号码callback：回调函数cmd：未知（必须）返回：JSON115API地址： http://cz.115.com/?ct=index&amp;ac=get_mobile_local&amp;callback=jsonp1333962541001&amp;mobile=15850781443参数：mobile：手机号码callback：回调函数返回：JSON有道api接口接口地址：http://www.youdao.com/smartresult-xml/search.s?type=mobile&amp;q=13892101112参数说明：type ： 参数手机归属地固定为mobileq ： 手机号码返回XML格式：&lt;?xml version=&quot;1.0&quot; encoding=&quot;gbk&quot;?&gt; &lt;smartresult&gt; &lt;product type=&quot;mobile&quot;&gt; &lt;phonenum&gt;13892101112&lt;/phonenum&gt; &lt;location&gt;陕西 延安&lt;/location&gt; &lt;/product&gt; &lt;/smartresult&gt;或者http://www.youdao.com/smartresult-xml/search.s?jsFlag=true&amp;type=mobile&amp;q=手机号码返回JSON格式：123456fYodaoCallBack(1, &#123; ‘product’:&apos;mobile’, &apos;phonenum’:’13892101112′, ’location’:&apos;陕西 延安’ &#125; , );096.me api接口查询手机号码归属地：http://www.096.me/api.php?phone=手机号&amp;mode={txt,xml}举例：http://www.096.me/api.php?phone=13892101111&amp;mode=txt返回：13892101111||陕西延安移动全球通卡 ||吉凶参半，惟赖勇气，贯彻力行，始可成功 吉带凶||举例：http://www.096.me/api.php?phone=13892101111&amp;mode=xml返回：13892101111 陕西延安移动全球通卡 吉凶参半，惟赖勇气，贯彻力行，始可成功 吉带凶]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS判断一个点是否在多边形内]]></title>
    <url>%2F2017%2F02%2F02%2FJS%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%86%85%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122//定义点的结构体function point()&#123; this.x=0; this.y=0;&#125;//计算一个点是否在多边形里,参数:点,多边形数组function PointInPoly(pt, poly) &#123; for (var c = false, i = -1, l = poly.length, j = l - 1; ++i &lt; l; j = i) ((poly[i].y &lt;= pt.y &amp;&amp; pt.y &lt; poly[j].y) || (poly[j].y &lt;= pt.y &amp;&amp; pt.y &lt; poly[i].y)) &amp;&amp; (pt.x &lt; (poly[j].x - poly[i].x) * (pt.y - poly[i].y) / (poly[j].y - poly[i].y) + poly[i].x) &amp;&amp; (c = !c); return c; &#125; //调用var pt=new point();pt.x=34.32812720562833;pt.y=108.93115997314453;var _poly=[&#123;x:1.1,y:1.1&#125;,&#123;x:3,y:1&#125;,&#123;x:6,y:4&#125;,&#123;x:2,y:10&#125;,&#123;x:1.1,y:1.1&#125;];var xx=PointInPoly(pt,_poly);alert(xx);]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS长数字格式化]]></title>
    <url>%2F2017%2F01%2F22%2FJS%E9%95%BF%E6%95%B0%E5%AD%97%E6%A0%BC%E5%BC%8F%E5%8C%96%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233/* 数字格式化 num:目标数字 precision:小数点后位数(默认所有) separator:分隔符(默认&apos;,&apos;) */function formatNumber(num, precision, separator)&#123; var parts; // 判断是否为数字 if (!isNaN(parseFloat(num)) &amp;&amp; isFinite(num)) &#123; // 把类似 .5, 5. 之类的数据转化成0.5, 5, 为数据精度处理做准, 至于为什么// 不在判断中直接写 if (!isNaN(num = parseFloat(num)) &amp;&amp; isFinite(num)) // 是因为parseFloat有一个奇怪的精度问题, 比如 parseFloat(12312312.1234567119) // 的值变成了 12312312.123456713 num = Number(num); // 处理小数点位数 num = (typeof precision !== &apos;undefined&apos; ? num.toFixed(precision) : num).toString(); // 分离数字的小数部分和整数部分 parts = num.split(&apos;.&apos;); // 整数部分加[separator]分隔, 借用一个著名的正则表达式 parts[0] = parts[0].toString().replace(/(\d)(?=(\d&#123;3&#125;)+(?!\d))/g, &apos;$1&apos; + (separator || &apos;,&apos;)); return parts.join(&apos;.&apos;); &#125; return NaN;&#125;测试：formatNumber(10000)&quot;10,000&quot;formatNumber(10000, 2)&quot;10,000.00&quot;formatNumber(10000.123456, 2)&quot;10,000.12&quot;formatNumber(10000.123456, 2, &apos; &apos;)&quot;10 000.12&quot;正则表达式方法：result = &quot;1234567890&quot;.replace(/\d+?(?=(?:\d&#123;3&#125;)+$)/img, &quot;$&amp; &quot;);]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[诗和远方不如同耕故乡]]></title>
    <url>%2F2017%2F01%2F07%2F%E8%AF%97%E5%92%8C%08%E8%BF%9C%E6%96%B9%E4%B8%8D%E5%A6%82%E5%90%8C%E8%80%95%E6%95%85%E4%B9%A1%2F</url>
    <content type="text"><![CDATA[父母在，家便在…我们终其一生拼搏奋斗，除了梦想，就是为了能找到家的影子，找到生活的样子，父母在，家 便在！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>思乡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS的颜色随机颜色]]></title>
    <url>%2F2017%2F01%2F03%2FCSS%E7%9A%84%E9%A2%9C%E8%89%B2%E9%9A%8F%E6%9C%BA%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[1(~~(Math.random()*(1&lt;&lt;24))).toString(16)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当我开始爱自己-卓别林]]></title>
    <url>%2F2017%2F01%2F01%2F%E5%BD%93%E6%88%91%E5%BC%80%E5%A7%8B%E7%88%B1%E8%87%AA%E5%B7%B1%2F</url>
    <content type="text"><![CDATA[查理·卓别林（Charlie Chaplin，1889年4月16日-1977年12月25日），生于英国伦敦，英国影视演员、导演、编剧。当我开始真正爱自己，我才认识到，所有的痛苦和情感的折磨，都只是提醒我：活着，不要违背自己的本心。今天我明白了，这叫作 “真实”。当我开始真正爱自己，我才懂得，把自己的愿望强加于人，是多么无礼，就算我知道，时机并不成熟，那个人还没有做好准备，就算那个人就是我自己。今天我明白了，这叫作 “尊重”。当我开始真正爱自己，我不再渴求不同的人生，我知道任何发生在我身边的事情，都是对我成长的邀请。今天我明白了，这叫作 “成熟”。当我开始真正爱自己，我才明白，我其实一直都在正确的时间、正确的地点，发生的一切都恰如其分，由此我得以平静。今天我明白了，这叫作 “自信”。当我开始真正爱自己，我不再牺牲自己的自由时间，不再去勾画什么宏伟的明天。今天我只做有趣和快乐的事，做自己热爱、让心欢喜的事，用我的方式、我的韵律。今天我明白了，这叫作 “单纯”。当我开始真正爱自己，我开始远离一切不健康的东西。不论是饮食和人物，还是事情和环境，我远离一切让我远离本真的东西。从前我把这叫作“追求健康的自私自利”，今天我明白了，这是 “自爱”。当我开始真正爱自己，我不再总想着要永远正确，不犯错误。今天我明白了，这叫作 “谦逊”。当我开始真正爱自己，我不再继续沉溺于过去，也不再为明天而忧虑，现在我只活在当下、活在此时此地，如此日复一日。今天我明白了，这叫做 “完美”。当我开始真正爱自己，我明白我的思虑让我变得贫乏和病态，但当我唤起了心灵的力量，理智就变成了一个重要的伙伴。这种组合我称之为 “心的智慧”。我们无需再害怕自己和他人的分歧、矛盾和问题，因为即使星星有时也会碰在一起，形成新的世界。今天我明白了，这就是 “生命”。]]></content>
      <categories>
        <category>诗-词-散文</category>
      </categories>
      <tags>
        <tag>查理·卓别林</tag>
      </tags>
  </entry>
</search>
